[
    {
      "title": "Java RMI - 'Phép Dịch Chuyển Tức Thời' Cho Đối Tượng Java",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-9/",
      "summary": "\u003cp\u003eChúng ta đã đi một chặng đường dài trong lập trình mạng Java: từ việc tìm địa chỉ (\u003ccode\u003eInetAddress\u003c/code\u003e), tải nội dung web (\u003ccode\u003eURLConnection\u003c/code\u003e), đến việc thiết lập kênh giao tiếp hai chiều tin cậy (\u003ccode\u003eTCP Socket\u003c/code\u003e), kênh tốc độ cao (\u003ccode\u003eUDP Socket\u003c/code\u003e), và thậm chí \u0026ldquo;đông lạnh\u0026rdquo; đối tượng để gửi đi (\u003ccode\u003eSerialization\u003c/code\u003e).\ns\nBây giờ, hãy đến với một khái niệm trừu tượng và mạnh mẽ hơn: \u003cstrong\u003eJava RMI (Remote Method Invocation - Gọi Phương Thức Từ Xa)\u003c/strong\u003e.\u003c/p\u003e",
      "content": "Chúng ta đã đi một chặng đường dài trong lập trình mạng Java: từ việc tìm địa chỉ (InetAddress), tải nội dung web (URLConnection), đến việc thiết lập kênh giao tiếp hai chiều tin cậy (TCP Socket), kênh tốc độ cao (UDP Socket), và thậm chí \u0026ldquo;đông lạnh\u0026rdquo; đối tượng để gửi đi (Serialization). s Bây giờ, hãy đến với một khái niệm trừu tượng và mạnh mẽ hơn: Java RMI (Remote Method Invocation - Gọi Phương Thức Từ Xa).\nHãy tưởng tượng bạn có thể ngồi ở máy Client và gọi một phương thức của đối tượng đang chạy trên máy Server y như thể đối tượng đó đang nằm ngay trên máy Client của bạn. Bạn không cần bận tâm đến việc mở Socket, tạo ObjectOutputStream, hay xử lý lỗi mạng. Bạn chỉ cần viết: remoteCalculator.add(5, 3) và nhận kết quả.\nĐó chính là phép màu của RMI! ✨ Nó tạo ra một lớp trừu tượng cao cấp, che giấu hoàn toàn sự phức tạp của việc giao tiếp mạng, cho phép bạn xây dựng các ứng dụng phân tán (Distributed Applications) một cách tự nhiên theo đúng phong cách Hướng Đối Tượng của Java.\nTại Sao Cần RMI? Vượt Lên Socket Cơ Bản\rLập trình Socket trực tiếp rất mạnh mẽ nhưng cũng rất \u0026ldquo;thủ công\u0026rdquo;:\nBạn phải tự định nghĩa giao thức (protocol). Bạn phải tự xử lý việc tuần tự hóa/giải tuần tự hóa dữ liệu. Bạn phải tự quản lý kết nối, xử lý lỗi mạng. RMI tự động hóa tất cả những việc này:\nGiao thức: RMI sử dụng giao thức riêng (JRMP) hoặc IIOP. Tuần tự hóa: RMI tự động dùng Java Serialization. Quản lý kết nối: RMI tự lo việc thiết lập và duy trì kết nối. Mô Hình Kiến Trúc RMI: Ai Làm Gì? 🎭\rMột hệ thống RMI điển hình bao gồm:\nRemote Interface: interface Java kế thừa java.rmi.Remote, định nghĩa các phương thức gọi từ xa (phải throws RemoteException). Đây là \u0026ldquo;hợp đồng\u0026rdquo;. Remote Object Implementation: Lớp Java implements Remote Interface, thường kế thừa java.rmi.server.UnicastRemoteObject. Chứa code logic thật sự trên Server. RMI Registry: \u0026ldquo;Danh bạ\u0026rdquo; chạy trên Server. Server đăng ký (bind) đối tượng vào Registry với một tên duy nhất. Stub: Proxy chạy trên Client, có cùng kiểu Remote Interface. Client lấy Stub từ Registry thông qua lookup(). Khi Client gọi phương thức trên Stub, Stub đóng gói tham số, gửi qua mạng. Skeleton (ẩn): Phía Server nhận yêu cầu từ Stub, giải nén, gọi phương thức trên Remote Object thật, đóng gói kết quả, gửi lại cho Stub. Ví Dụ Code Chi Tiết: Máy Tính Từ Xa\rChúng ta sẽ tạo 4 file .java riêng biệt.\n// File: Calculator.java (Remote Interface) import java.rmi.Remote; import java.rmi.RemoteException; public interface Calculator extends Remote { int add(int a, int b) throws RemoteException; int subtract(int a, int b) throws RemoteException; // Thêm phương thức trừ } // -------------------------------------------------- // File: CalculatorImpl.java (Remote Object Implementation) import java.rmi.server.UnicastRemoteObject; import java.rmi.RemoteException; public class CalculatorImpl extends UnicastRemoteObject implements Calculator { // Constructor mặc định (bắt buộc cho UnicastRemoteObject) protected CalculatorImpl() throws RemoteException { super(); } @Override public int add(int a, int b) throws RemoteException { System.out.println(\u0026#34;SERVER: Nhận được yêu cầu add(\u0026#34; + a + \u0026#34;, \u0026#34; + b + \u0026#34;)\u0026#34;); return a + b; } @Override public int subtract(int a, int b) throws RemoteException { System.out.println(\u0026#34;SERVER: Nhận được yêu cầu subtract(\u0026#34; + a + \u0026#34;, \u0026#34; + b + \u0026#34;)\u0026#34;); return a - b; } } // -------------------------------------------------- // File: Server.java (Khởi tạo, Đăng ký) import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.RemoteException; public class Server { public static void main(String[] args) { try { // 1. Tạo đối tượng dịch vụ CalculatorImpl calculator = new CalculatorImpl(); System.out.println(\u0026#34;SERVER: Đã tạo đối tượng CalculatorImpl.\u0026#34;); // 2. Tạo hoặc lấy RMI Registry đang chạy ở cổng 1099 Registry registry; try { registry = LocateRegistry.createRegistry(1099); // Thử tạo mới System.out.println(\u0026#34;SERVER: Đã tạo RMI Registry ở cổng 1099.\u0026#34;); } catch (RemoteException e) { System.out.println(\u0026#34;SERVER: RMI Registry có vẻ đã chạy, đang lấy tham chiếu...\u0026#34;); registry = LocateRegistry.getRegistry(1099); } // 3. Đăng ký (bind) đối tượng dịch vụ vào Registry registry.rebind(\u0026#34;MyCalculatorService\u0026#34;, calculator); // Dùng tên khác System.out.println(\u0026#34;SERVER: Đã đăng ký \u0026#39;MyCalculatorService\u0026#39; vào Registry.\u0026#34;); System.out.println(\u0026#34;SERVER: Sẵn sàng nhận yêu cầu từ Client.\u0026#34;); } catch (Exception e) { System.err.println(\u0026#34;SERVER: Gặp lỗi: \u0026#34; + e.toString()); e.printStackTrace(); } } } // -------------------------------------------------- // File: Client.java (Tra cứu, Gọi phương thức) import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.util.Scanner; public class Client { public static void main(String[] args) { String serverHost = \u0026#34;localhost\u0026#34;; if (args.length \u0026gt; 0) { serverHost = args[0]; } try { // 1. Lấy tham chiếu đến Registry System.out.println(\u0026#34;CLIENT: Đang kết nối đến RMI Registry tại \u0026#34; + serverHost + \u0026#34;:1099...\u0026#34;); Registry registry = LocateRegistry.getRegistry(serverHost, 1099); System.out.println(\u0026#34;CLIENT: Kết nối Registry thành công.\u0026#34;); // 2. Tra cứu (lookup) đối tượng từ xa System.out.println(\u0026#34;CLIENT: Đang tìm dịch vụ \u0026#39;MyCalculatorService\u0026#39;...\u0026#34;); Calculator calculatorStub = (Calculator) registry.lookup(\u0026#34;MyCalculatorService\u0026#34;); System.out.println(\u0026#34;CLIENT: Đã lấy được Stub của MyCalculatorService.\u0026#34;); // 3. Tương tác với người dùng và gọi phương thức từ xa Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\u0026#34;\\nChọn phép toán:\u0026#34;); System.out.println(\u0026#34;1. Cộng (add)\u0026#34;); System.out.println(\u0026#34;2. Trừ (subtract)\u0026#34;); System.out.println(\u0026#34;0. Thoát\u0026#34;); System.out.print(\u0026#34;Lựa chọn của bạn: \u0026#34;); int choice = scanner.nextInt(); if (choice == 0) break; System.out.print(\u0026#34;Nhập số a: \u0026#34;); int a = scanner.nextInt(); System.out.print(\u0026#34;Nhập số b: \u0026#34;); int b = scanner.nextInt(); int result; if (choice == 1) { System.out.println(\u0026#34;CLIENT: Gọi phương thức add(\u0026#34; + a + \u0026#34;, \u0026#34; + b + \u0026#34;) từ xa...\u0026#34;); result = calculatorStub.add(a, b); System.out.println(\u0026#34;CLIENT: Nhận kết quả từ Server: \u0026#34; + result); } else if (choice == 2) { System.out.println(\u0026#34;CLIENT: Gọi phương thức subtract(\u0026#34; + a + \u0026#34;, \u0026#34; + b + \u0026#34;) từ xa...\u0026#34;); result = calculatorStub.subtract(a, b); System.out.println(\u0026#34;CLIENT: Nhận kết quả từ Server: \u0026#34; + result); } else { System.out.println(\u0026#34;Lựa chọn không hợp lệ.\u0026#34;); } } scanner.close(); System.out.println(\u0026#34;CLIENT: Kết thúc.\u0026#34;); } catch (Exception e) { System.err.println(\u0026#34;CLIENT: Gặp lỗi: \u0026#34; + e.toString()); e.printStackTrace(); } } } ",
      "categories": ["Networking"],
      "tags": ["Java","Networking","RMI"]
    },
    {
      "title": "JavaScript 'Gọi Điện' Về Server - Fetch API \u0026 async/await",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-8/",
      "summary": "\u003cp\u003eChúng ta đã dành nhiều thời gian khám phá cách Java hoạt động ở phía \u003cstrong\u003eback-end\u003c/strong\u003e (máy chủ), xử lý logic, kết nối database, và giao tiếp mạng cấp thấp. Giờ là lúc chuyển sang phía \u003cstrong\u003efront-end\u003c/strong\u003e - thế giới của trình duyệt web, nơi \u003cstrong\u003eJavaScript\u003c/strong\u003e là vua. 👑\u003c/p\u003e\n\u003cp\u003eTrong các ứng dụng web hiện đại (Single Page Applications - SPAs), trải nghiệm người dùng mượt mà là yếu tố then chốt. Khi bạn \u0026ldquo;thích\u0026rdquo; một bài đăng trên Facebook, trang web không tải lại hoàn toàn. Thay vào đó, JavaScript chạy trong trình duyệt của bạn sẽ âm thầm gửi một yêu cầu nhỏ lên server (\u0026ldquo;Người dùng A thích bài đăng X\u0026rdquo;), server xử lý, và JavaScript cập nhật giao diện (nút \u0026ldquo;thích\u0026rdquo; chuyển màu xanh, bộ đếm tăng lên) mà không làm gián đoạn trải nghiệm.\u003c/p\u003e",
      "content": "Chúng ta đã dành nhiều thời gian khám phá cách Java hoạt động ở phía back-end (máy chủ), xử lý logic, kết nối database, và giao tiếp mạng cấp thấp. Giờ là lúc chuyển sang phía front-end - thế giới của trình duyệt web, nơi JavaScript là vua. 👑\nTrong các ứng dụng web hiện đại (Single Page Applications - SPAs), trải nghiệm người dùng mượt mà là yếu tố then chốt. Khi bạn \u0026ldquo;thích\u0026rdquo; một bài đăng trên Facebook, trang web không tải lại hoàn toàn. Thay vào đó, JavaScript chạy trong trình duyệt của bạn sẽ âm thầm gửi một yêu cầu nhỏ lên server (\u0026ldquo;Người dùng A thích bài đăng X\u0026rdquo;), server xử lý, và JavaScript cập nhật giao diện (nút \u0026ldquo;thích\u0026rdquo; chuyển màu xanh, bộ đếm tăng lên) mà không làm gián đoạn trải nghiệm.\nCơ chế \u0026ldquo;gọi điện về server\u0026rdquo; mà không cần tải lại trang này được thực hiện chủ yếu thông qua AJAX (Asynchronous JavaScript and XML) - mặc dù ngày nay XML ít được dùng hơn JSON. Công cụ tiêu chuẩn và mạnh mẽ nhất để thực hiện AJAX trong JavaScript hiện đại là Fetch API.\nFetch API: Người Đưa Tin Hiện Đại 🚀\rfetch() là một hàm toàn cục (window.fetch()) được tích hợp sẵn trong hầu hết các trình duyệt hiện đại. Nó cung cấp một cách thức mạnh mẽ và linh hoạt để thực hiện các yêu cầu mạng (chủ yếu là HTTP/HTTPS). Nó là phiên bản hiện đại, mạnh mẽ hơn của XMLHttpRequest.\nThách Thức Cốt Lõi: Bất Đồng Bộ (Asynchronicity) ⏳\rĐây là khái niệm quan trọng nhất cần hiểu khi làm việc với mạng trong JavaScript. Khi bạn gọi fetch('...'), JavaScript KHÔNG CHỜ ĐỢI. Nó tiếp tục thực thi các dòng code tiếp theo ngay lập tức. Vài mili giây hoặc vài giây sau, khi trình duyệt tải xong, JavaScript mới nhận dữ liệu và xử lý. Bất đồng bộ giúp giao diện người dùng luôn mượt mà.\nĐể quản lý việc \u0026ldquo;nhận dữ liệu sau\u0026rdquo; này, JavaScript dùng Promises (Lời hứa).\nQuản Lý Bất Đồng Bộ: Promises và .then()\rfetch() không trả về dữ liệu ngay lập tức. Nó trả về một Promise (Lời hứa). Promise giống như một giấy hẹn: \u0026ldquo;Tôi hứa sẽ có kết quả (thành công hoặc thất bại) trong tương lai\u0026rdquo;.\nBạn sử dụng phương thức .then() để \u0026ldquo;đăng ký\u0026rdquo; một hàm callback sẽ được thực thi khi lời hứa được hoàn thành (resolved). Bạn dùng .catch() để xử lý khi lời hứa thất bại (rejected).\n// Đây là code JavaScript, chạy trong thẻ \u0026lt;script\u0026gt; của file HTML // Hoặc chạy ngay trong Console (F12) của trình duyệt const userListElement = document.getElementById(\u0026#39;user-list\u0026#39;); // Giả sử có \u0026lt;ul id=\u0026#34;user-list\u0026#34;\u0026gt; console.log(\u0026#34;Bắt đầu tải danh sách người dùng...\u0026#34;); if (userListElement) userListElement.innerHTML = \u0026#39;\u0026lt;li\u0026gt;Đang tải...\u0026lt;/li\u0026gt;\u0026#39;; // Thông báo đang tải fetch(\u0026#39;[https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)\u0026#39;) .then(response =\u0026gt; { console.log(\u0026#34;Nhận được phản hồi từ server (chưa phải dữ liệu)\u0026#34;); // Kiểm tra xem server có trả về lỗi HTTP không (4xx, 5xx) if (!response.ok) { // fetch() chỉ reject khi có lỗi mạng thực sự, không phải lỗi HTTP // Nên phải tự kiểm tra response.ok throw new Error(`HTTP error! status: ${response.status}`); } else { // response.json() cũng trả về một Promise khác! return response.json(); // Promise này resolve với dữ liệu JSON đã parse } }) .then(users =\u0026gt; { console.log(\u0026#34;Đã nhận và parse dữ liệu người dùng:\u0026#34;, users); if (userListElement) { userListElement.innerHTML = \u0026#39;\u0026#39;; // Xóa chữ \u0026#34;Đang tải...\u0026#34; users.forEach(user =\u0026gt; { const listItem = document.createElement(\u0026#39;li\u0026#39;); listItem.textContent = `${user.name} (${user.email})`; userListElement.appendChild(listItem); }); } }) .catch(error =\u0026gt; { console.error(\u0026#39;Không thể tải dữ liệu:\u0026#39;, error); if (userListElement) userListElement.innerHTML = `\u0026lt;li\u0026gt;Lỗi: ${error.message}\u0026lt;/li\u0026gt;`; }); console.log(\u0026#34;Code này chạy ngay lập tức, không chờ fetch xong.\u0026#34;); ",
      "categories": ["JavaScript"],
      "tags": ["JavaScript","Networking","Fetch API","async-await"]
    },
    {
      "title": "Tuần Tự Hóa (Serialization) - Phép Thuật 'Đông Lạnh' và 'Hồi Sinh' Đối Tượng Java",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-7/",
      "summary": "\u003cp\u003eChúng ta đã thành thạo việc gửi các chuỗi ký tự (text) qua mạng bằng cả TCP và UDP. Nhưng sức mạnh thực sự của Java nằm ở Lập trình Hướng Đối Tượng (OOP). Sẽ ra sao nếu chúng ta muốn gửi không chỉ là text, mà là \u003cstrong\u003etoàn bộ trạng thái của một đối tượng Java\u003c/strong\u003e - ví dụ, một đối tượng \u003ccode\u003eUser\u003c/code\u003e với \u003ccode\u003eusername\u003c/code\u003e, \u003ccode\u003epasswordHash\u003c/code\u003e, \u003ccode\u003elastLoginTime\u003c/code\u003e - từ Client lên Server để lưu vào database, hoặc từ Server gửi xuống Client để cập nhật giao diện?\u003c/p\u003e",
      "content": "Chúng ta đã thành thạo việc gửi các chuỗi ký tự (text) qua mạng bằng cả TCP và UDP. Nhưng sức mạnh thực sự của Java nằm ở Lập trình Hướng Đối Tượng (OOP). Sẽ ra sao nếu chúng ta muốn gửi không chỉ là text, mà là toàn bộ trạng thái của một đối tượng Java - ví dụ, một đối tượng User với username, passwordHash, lastLoginTime - từ Client lên Server để lưu vào database, hoặc từ Server gửi xuống Client để cập nhật giao diện?\nVấn đề là, mạng Internet hay ổ đĩa cứng không hiểu khái niệm \u0026ldquo;đối tượng Java\u0026rdquo; trong bộ nhớ RAM là gì. Chúng chỉ hiểu dãy các byte (sequence of bytes).\nTuần tự hóa (Serialization) chính là cây cầu nối giữa hai thế giới này. Nó là quá trình \u0026ldquo;đông lạnh\u0026rdquo; 🥶 một đối tượng Java đang \u0026ldquo;sống\u0026rdquo; trong bộ nhớ (cùng với tất cả các thuộc tính của nó) thành một luồng byte tuần tự. Luồng byte này sau đó có thể:\nLưu trữ: Ghi ra file để lưu trạng thái (.ser). Vận chuyển: Gửi qua mạng (TCP, UDP). Truyền giữa các tiến trình: Chia sẻ dữ liệu giữa các ứng dụng khác nhau. Giải tuần tự hóa (Deserialization) là quá trình ngược lại: đọc luồng byte đó từ file hoặc từ mạng và \u0026ldquo;rã đông\u0026rdquo; 🔥, tái tạo lại (reconstruct) một bản sao y hệt của đối tượng ban đầu trong bộ nhớ.\nĐiều Kiện Tiên Quyết: Giao Diện java.io.Serializable\rĐể một đối tượng Java có khả năng được \u0026ldquo;đông lạnh\u0026rdquo;, Lớp (Class) của nó bắt buộc phải triển khai (implements) giao diện java.io.Serializable.\nSerializable là một Marker Interface (Giao diện đánh dấu). Nó không định nghĩa bất kỳ phương thức nào mà lớp của bạn phải viết code. Việc implements Serializable chỉ đơn giản là một \u0026ldquo;tín hiệu\u0026rdquo; báo cho JVM biết rằng \u0026ldquo;Tôi cho phép đối tượng thuộc lớp này được tuần tự hóa\u0026rdquo;. JVM sẽ tự động lo phần còn lại dựa trên cấu trúc của lớp.\nQuan trọng: Nếu lớp của bạn chứa thuộc tính là đối tượng của lớp khác (ví dụ: User có thuộc tính Address address), thì lớp Address đó cũng phải implements Serializable. Nếu không, quá trình tuần tự hóa sẽ thất bại.\nBộ Đôi Quyền Lực: ObjectOutputStream \u0026amp; ObjectInputStream\rĐể thực hiện việc \u0026ldquo;đông lạnh\u0026rdquo; và \u0026ldquo;hồi sinh\u0026rdquo;, Java cung cấp hai lớp luồng đặc biệt (thuộc mô hình Decorator):\njava.io.ObjectOutputStream: Dùng để tuần tự hóa (ghi) đối tượng. Nó \u0026ldquo;bọc\u0026rdquo; một OutputStream cơ bản và có phương thức writeObject(yourObject). java.io.ObjectInputStream: Dùng để giải tuần tự hóa (đọc) đối tượng. Nó \u0026ldquo;bọc\u0026rdquo; một InputStream cơ bản và có phương thức readObject(), trả về Object (cần ép kiểu). Ví dụ: Lưu và Tải lại Đối Tượng User vào File\rimport java.io.*; // Lớp User phải Serializable class User implements Serializable { private static final long serialVersionUID = 1L; // Để quản lý phiên bản String username; transient String password; // Thuộc tính này sẽ KHÔNG được lưu int level; public User(String username, String password, int level) { this.username = username; this.password = password; this.level = level; } @Override public String toString() { // Lưu ý: Password sẽ là null khi đọc lại do \u0026#39;transient\u0026#39; return \u0026#34;User [username=\u0026#34; + username + \u0026#34;, password=\u0026#34; + password + \u0026#34;, level=\u0026#34; + level + \u0026#34;]\u0026#34;; } } // Lớp chính để chạy demo public class SerializationFileDemo { public static void main(String[] args) { String filename = \u0026#34;user.ser\u0026#34;; // File để lưu đối tượng // --- BƯỚC 1: TẠO VÀ TUẦN TỰ HÓA (GHI) ĐỐI TƯỢNG --- User userToWrite = new User(\u0026#34;NguyenVanA\u0026#34;, \u0026#34;mySecret123\u0026#34;, 5); System.out.println(\u0026#34;Đối tượng gốc:\\n\u0026#34; + userToWrite); try ( FileOutputStream fos = new FileOutputStream(filename); ObjectOutputStream oos = new ObjectOutputStream(fos) // Bọc FileOutputStream ) { System.out.println(\u0026#34;\\nĐang tuần tự hóa và ghi ra file...\u0026#34;); oos.writeObject(userToWrite); // Thực hiện \u0026#34;đông lạnh\u0026#34; và ghi System.out.println(\u0026#34;Ghi file thành công!\u0026#34;); } catch (IOException e) { System.err.println(\u0026#34;Lỗi khi ghi đối tượng: \u0026#34; + e.getMessage()); } // --- BƯỚC 2: GIẢI TUẦN TỰ HÓA (ĐỌC) ĐỐI TƯỢNG --- System.out.println(\u0026#34;\\n--- Đọc lại đối tượng từ file ---\u0026#34;); User userToRead = null; try ( FileInputStream fis = new FileInputStream(filename); ObjectInputStream ois = new ObjectInputStream(fis) // Bọc FileInputStream ) { System.out.println(\u0026#34;Đang đọc và giải tuần tự hóa...\u0026#34;); // Đọc từ luồng byte và \u0026#34;hồi sinh\u0026#34; thành đối tượng User userToRead = (User) ois.readObject(); System.out.println(\u0026#34;Đọc thành công!\u0026#34;); System.out.println(\u0026#34;Đối tượng đọc được:\\n\u0026#34; + userToRead); } catch (IOException e) { System.err.println(\u0026#34;Lỗi khi đọc đối tượng: \u0026#34; + e.getMessage()); } catch (ClassNotFoundException e) { // Xảy ra nếu chương trình đọc không tìm thấy file .class của lớp User System.err.println(\u0026#34;Lỗi: Không tìm thấy lớp \u0026#39;User\u0026#39; khi giải tuần tự hóa.\u0026#34;); } } } ",
      "categories": ["Java"],
      "tags": ["Java","Serialization","Object Stream"]
    },
    {
      "title": "Socket UDP - Gửi Dữ Liệu Tốc Hành, Không Cần 'Bắt Tay'",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-6/",
      "summary": "\u003cp\u003eTrong thế giới mạng, TCP giống như một cuộc gọi điện thoại được đảm bảo: bạn phải quay số, chờ người kia nhấc máy, nói chuyện và đảm bảo từng lời được nghe đúng. Ngược lại, \u003cstrong\u003eUDP (User Datagram Protocol)\u003c/strong\u003e giống như việc bạn \u003cstrong\u003eviết thông tin lên một loạt bưu thiếp và thả vào hòm thư\u003c/strong\u003e 📮.\u003c/p\u003e\n\u003cp\u003eĐặc điểm chính của UDP:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eKhông Kết Nối (Connectionless):\u003c/strong\u003e Không cần \u0026ldquo;bắt tay\u0026rdquo; (handshake). Bên gửi chỉ cần biết địa chỉ IP và cổng của bên nhận, đóng gói dữ liệu vào một \u0026ldquo;bưu thiếp\u0026rdquo; (\u003ccode\u003eDatagramPacket\u003c/code\u003e) và \u0026ldquo;ném\u0026rdquo; nó vào mạng. Bên nhận chỉ cần \u0026ldquo;mở hòm thư\u0026rdquo; (\u003ccode\u003eDatagramSocket\u003c/code\u003e) ở cổng đó và chờ thư đến.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKhông Đáng Tin Cậy (Unreliable):\u003c/strong\u003e Internet (bưu điện) \u003cstrong\u003ekhông đảm bảo\u003c/strong\u003e bưu thiếp sẽ đến đích. Nó có thể bị thất lạc, bị hỏng trên đường đi, hoặc đến nơi nhưng bị hỏng (checksum error). UDP không tự động gửi lại. Nếu cần độ tin cậy, ứng dụng tầng trên (ví dụ: game của bạn) phải tự xử lý.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKhông Theo Thứ Tự (Out-of-Order Delivery):\u003c/strong\u003e Bạn gửi 3 bưu thiếp 1, 2, 3. Người nhận có thể nhận được theo thứ tự 3, 1, 2 hoặc chỉ nhận được 1 và 3. UDP không đảm bảo thứ tự.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNhẹ và Nhanh (Lightweight \u0026amp; Fast):\u003c/strong\u003e Chính vì bỏ qua các cơ chế đảm bảo của TCP (handshake, sequence number, acknowledgement, retransmission), UDP có phần header rất nhỏ và xử lý rất nhanh. Nó không gây thêm độ trễ (latency) không cần thiết.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eKhi nào nên dùng UDP?\u003c/strong\u003e\nKhi \u003cstrong\u003etốc độ\u003c/strong\u003e quan trọng hơn \u003cstrong\u003eđộ tin cậy tuyệt đối\u003c/strong\u003e, và ứng dụng có thể chấp nhận hoặc tự xử lý việc mất mát/sai thứ tự gói tin.\u003c/p\u003e",
      "content": "Trong thế giới mạng, TCP giống như một cuộc gọi điện thoại được đảm bảo: bạn phải quay số, chờ người kia nhấc máy, nói chuyện và đảm bảo từng lời được nghe đúng. Ngược lại, UDP (User Datagram Protocol) giống như việc bạn viết thông tin lên một loạt bưu thiếp và thả vào hòm thư 📮.\nĐặc điểm chính của UDP:\nKhông Kết Nối (Connectionless): Không cần \u0026ldquo;bắt tay\u0026rdquo; (handshake). Bên gửi chỉ cần biết địa chỉ IP và cổng của bên nhận, đóng gói dữ liệu vào một \u0026ldquo;bưu thiếp\u0026rdquo; (DatagramPacket) và \u0026ldquo;ném\u0026rdquo; nó vào mạng. Bên nhận chỉ cần \u0026ldquo;mở hòm thư\u0026rdquo; (DatagramSocket) ở cổng đó và chờ thư đến. Không Đáng Tin Cậy (Unreliable): Internet (bưu điện) không đảm bảo bưu thiếp sẽ đến đích. Nó có thể bị thất lạc, bị hỏng trên đường đi, hoặc đến nơi nhưng bị hỏng (checksum error). UDP không tự động gửi lại. Nếu cần độ tin cậy, ứng dụng tầng trên (ví dụ: game của bạn) phải tự xử lý. Không Theo Thứ Tự (Out-of-Order Delivery): Bạn gửi 3 bưu thiếp 1, 2, 3. Người nhận có thể nhận được theo thứ tự 3, 1, 2 hoặc chỉ nhận được 1 và 3. UDP không đảm bảo thứ tự. Nhẹ và Nhanh (Lightweight \u0026amp; Fast): Chính vì bỏ qua các cơ chế đảm bảo của TCP (handshake, sequence number, acknowledgement, retransmission), UDP có phần header rất nhỏ và xử lý rất nhanh. Nó không gây thêm độ trễ (latency) không cần thiết. Khi nào nên dùng UDP? Khi tốc độ quan trọng hơn độ tin cậy tuyệt đối, và ứng dụng có thể chấp nhận hoặc tự xử lý việc mất mát/sai thứ tự gói tin.\nGame thời gian thực (Real-time Gaming): Gửi vị trí người chơi. Mất một gói tin vị trí cũ không quá tệ, miễn là các vị trí mới đến nhanh. Truyền phát Video/Audio (Streaming - VoIP, IPTV): Mất một vài khung hình/mẫu âm thanh thường ít ảnh hưởng hơn là bị giật/lag do chờ gói tin bị mất của TCP. DNS (Domain Name System): Yêu cầu phân giải tên miền cần phản hồi nhanh nhất có thể. DHCP (Dynamic Host Configuration Protocol): Cấp phát địa chỉ IP trong mạng LAN. Thành Phần Chính: DatagramSocket và DatagramPacket\rThay vì Socket và Stream của TCP, UDP dùng:\njava.net.DatagramSocket: Đại diện cho \u0026ldquo;hòm thư\u0026rdquo; tại một cổng (port) cụ thể trên máy bạn. Nó dùng để gửi và nhận các DatagramPacket. java.net.DatagramPacket: Chính là \u0026ldquo;tấm bưu thiếp\u0026rdquo;. Nó là một gói dữ liệu chứa: Mảng byte dữ liệu (byte[] data). Độ dài dữ liệu (int length). Địa chỉ IP của người nhận/người gửi (InetAddress address). Cổng của người nhận/người gửi (int port). 1. UDPEchoServer.java - Người Nhận và Phản Hồi Bưu Thiếp 📬\rServer tạo DatagramSocket để lắng nghe trên một cổng cố định.\nimport java.net.DatagramSocket; import java.net.DatagramPacket; import java.net.InetAddress; import java.io.IOException; public class UDPEchoServer { public static void main(String[] args) { final int PORT = 9876; // Cổng lắng nghe final int BUFFER_SIZE = 1024; // Kích thước tối đa của một bưu thiếp nhận DatagramSocket socket = null; try { // 1. Tạo DatagramSocket để lắng nghe trên PORT socket = new DatagramSocket(PORT); System.out.println(\u0026#34;UDP Echo Server đang lắng nghe trên cổng \u0026#34; + PORT + \u0026#34;...\u0026#34;); byte[] receiveBuffer = new byte[BUFFER_SIZE]; // Vòng lặp vô hạn để phục vụ nhiều client (nhưng vẫn đơn tuyến) while (true) { // 2. Tạo DatagramPacket rỗng để chuẩn bị nhận dữ liệu // Packet này sẽ được điền thông tin (dữ liệu, IP, port người gửi) khi nhận DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length); // 3. Chờ nhận Packet (blocking call) // Chương trình sẽ dừng ở đây cho đến khi có packet đến socket.receive(receivePacket); // 4. Xử lý Packet nhận được InetAddress clientAddress = receivePacket.getAddress(); // Lấy IP người gửi int clientPort = receivePacket.getPort(); // Lấy Port người gửi // Lấy dữ liệu, chỉ lấy đúng phần có nội dung (getLength) String clientMessage = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Nhận từ [\u0026#34; + clientAddress.getHostAddress() + \u0026#34;:\u0026#34; + clientPort + \u0026#34;]: \u0026#34; + clientMessage); // 5. Chuẩn bị Packet để gửi phản hồi (echo) byte[] sendBuffer = clientMessage.toUpperCase().getBytes(); // Chuyển thành chữ hoa rồi gửi lại // Tạo Packet gửi đi, chỉ rõ địa chỉ và port của Client đã gửi đến DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, clientAddress, clientPort); // 6. Gửi Packet phản hồi socket.send(sendPacket); System.out.println(\u0026#34; -\u0026gt; Đã gửi phản hồi echo (chữ hoa)\u0026#34;); // Reset buffer nhận cho lần lặp sau (không bắt buộc nhưng nên làm) // receiveBuffer = new byte[BUFFER_SIZE]; // Hoặc dùng Arrays.fill } } catch (IOException e) { System.err.println(\u0026#34;Lỗi Server UDP: \u0026#34; + e.getMessage()); e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); System.out.println(\u0026#34;Server UDP đã đóng.\u0026#34;); } } } } ",
      "categories": ["Networking"],
      "tags": ["Java","Networking","Socket","UDP"]
    },
    {
      "title": "Socket TCP - Thiết Lập Đường Dây Nóng Hai Chiều",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-5/",
      "summary": "\u003cp\u003eỞ bài trước, \u003ccode\u003eURLConnection\u003c/code\u003e giống như việc bạn gửi yêu cầu đến một máy chủ web và nhận lại trang HTML - một tương tác khá thụ động. Bây giờ, chúng ta sẽ bước vào thế giới \u0026ldquo;chủ động\u0026rdquo; hơn: tạo ra một kênh giao tiếp \u003cstrong\u003ehai chiều\u003c/strong\u003e, \u003cstrong\u003eliên tục\u003c/strong\u003e giữa hai chương trình Java chạy trên các máy khác nhau (hoặc trên cùng một máy). Công cụ chính cho việc này là \u003cstrong\u003eSocket\u003c/strong\u003e. 🔌\u003c/p\u003e",
      "content": "Ở bài trước, URLConnection giống như việc bạn gửi yêu cầu đến một máy chủ web và nhận lại trang HTML - một tương tác khá thụ động. Bây giờ, chúng ta sẽ bước vào thế giới \u0026ldquo;chủ động\u0026rdquo; hơn: tạo ra một kênh giao tiếp hai chiều, liên tục giữa hai chương trình Java chạy trên các máy khác nhau (hoặc trên cùng một máy). Công cụ chính cho việc này là Socket. 🔌\nHãy tưởng tượng Socket như một cặp điện thoại được kết nối qua một đường dây riêng. Giao thức TCP (Transmission Control Protocol) chính là \u0026ldquo;dịch vụ đảm bảo\u0026rdquo; của công ty viễn thông chạy trên đường dây đó.\nKhi bạn lập trình với Socket TCP, bạn đang mô phỏng một cuộc gọi điện thoại:\nHướng Kết Nối (Connection-Oriented): Phải có sự \u0026ldquo;bắt tay\u0026rdquo; (handshake) ban đầu. Client (người gọi) phải chủ động quay số (địa chỉ IP + cổng) của Server (người nghe). Server phải \u0026ldquo;nhấc máy\u0026rdquo; (chấp nhận kết nối) trước khi cuộc trò chuyện bắt đầu. Một kết nối ảo được thiết lập và duy trì. Đáng Tin Cậy (Reliable): Đây là điểm mạnh nhất của TCP. Nó đảm bảo rằng mọi byte dữ liệu bạn gửi đi sẽ đến được đầu bên kia, đúng thứ tự, và không bị lỗi. Nếu một gói tin bị mất trên đường truyền, TCP sẽ tự động phát hiện và yêu cầu gửi lại mà bạn không cần can thiệp. Giống như nhà mạng đảm bảo bạn không bị mất chữ nào khi nói chuyện. Dựa Trên Luồng (Stream-Based): Sau khi kết nối thành công, TCP tạo ra hai \u0026ldquo;đường ống\u0026rdquo; (luồng I/O) ảo giữa hai điện thoại: một InputStream để \u0026ldquo;nghe\u0026rdquo; dữ liệu đến và một OutputStream để \u0026ldquo;nói\u0026rdquo; dữ liệu đi. Bạn chỉ cần đọc/ghi vào các luồng này, TCP sẽ lo phần còn lại. Mô hình kinh điển của Socket TCP là Client-Server:\nServer: Chạy trước, \u0026ldquo;mở\u0026rdquo; một cổng (port) trên máy và lắng nghe các yêu cầu kết nối đến. Nó giống như một tổng đài viên chờ điện thoại reo. Client: Chạy sau, biết địa chỉ IP và cổng của Server, chủ động thực hiện kết nối. Nó là người gọi đến tổng đài. 1. Server.java - Tổng Đài Viên Kiên Nhẫn ☎️\rServer sử dụng lớp java.net.ServerSocket để \u0026ldquo;đặt\u0026rdquo; một dịch vụ tại một cổng cụ thể và chờ đợi.\nimport java.net.ServerSocket; import java.net.Socket; import java.io.PrintWriter; // Dùng PrintWriter cho tiện gửi text import java.io.BufferedReader; // Dùng BufferedReader cho tiện đọc text import java.io.InputStreamReader; import java.io.IOException; import java.net.InetAddress; public class TCPEchoServer { public static void main(String[] args) { final int PORT = 12345; // Chọn một cổng chưa được sử dụng (trên 1024) ServerSocket serverSocket = null; Socket clientSocket = null; BufferedReader reader = null; PrintWriter writer = null; try { // 1. Tạo ServerSocket để lắng nghe trên cổng PORT // Tham số thứ 2 (backlog) là số lượng kết nối chờ tối đa trong hàng đợi serverSocket = new ServerSocket(PORT, 50); InetAddress serverIP = InetAddress.getLocalHost(); // Lấy IP của máy chủ System.out.println(\u0026#34;Echo Server đang chạy tại IP: \u0026#34; + serverIP.getHostAddress() + \u0026#34; trên cổng \u0026#34; + PORT); System.out.println(\u0026#34;Đang chờ Client kết nối...\u0026#34;); // 2. Chấp nhận kết nối từ Client (blocking call) // Chương trình sẽ dừng ở đây cho đến khi có Client kết nối clientSocket = serverSocket.accept(); InetAddress clientIP = clientSocket.getInetAddress(); int clientPort = clientSocket.getPort(); System.out.println(\u0026#34;-\u0026gt; Client đã kết nối từ IP: \u0026#34; + clientIP.getHostAddress() + \u0026#34;, Port: \u0026#34; + clientPort); // 3. Tạo luồng đọc (để nhận từ Client) và luồng ghi (để gửi cho Client) // Bọc InputStream bằng InputStreamReader (chuyển byte thành char) // và BufferedReader (đọc cả dòng) reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); // Bọc OutputStream bằng PrintWriter (ghi text tiện lợi, autoFlush=true để tự đẩy đi) writer = new PrintWriter(clientSocket.getOutputStream(), true); // 4. Vòng lặp giao tiếp: Đọc tin nhắn và gửi lại (Echo) String clientMessage; System.out.println(\u0026#34;Bắt đầu phiên Echo. Gõ \u0026#39;bye\u0026#39; từ Client để kết thúc.\u0026#34;); while ((clientMessage = reader.readLine()) != null) { // Đọc từng dòng Client gửi System.out.println(\u0026#34; Client -\u0026gt; Server: \u0026#34; + clientMessage); // Kiểm tra điều kiện dừng if (\u0026#34;bye\u0026#34;.equalsIgnoreCase(clientMessage.trim())) { writer.println(\u0026#34;Tạm biệt!\u0026#34;); // Gửi lời chào cuối break; // Thoát vòng lặp } // Gửi lại (echo) tin nhắn cho Client, thêm tiền tố \u0026#34;Server Echo: \u0026#34; writer.println(\u0026#34;Server Echo: \u0026#34; + clientMessage); } } catch (IOException e) { System.err.println(\u0026#34;Lỗi Server: \u0026#34; + e.getMessage()); e.printStackTrace(); } finally { // 5. Đóng tất cả tài nguyên (rất quan trọng!) // Đóng theo thứ tự ngược lại khi mở System.out.println(\u0026#34;Đang đóng kết nối...\u0026#34;); try { if (writer != null) writer.close(); if (reader != null) reader.close(); if (clientSocket != null) clientSocket.close(); if (serverSocket != null) serverSocket.close(); System.out.println(\u0026#34;Server đã dừng.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } } ",
      "categories": ["Networking"],
      "tags": ["Java","Networking","Socket","TCP"]
    },
    {
      "title": "Ba Chàng Ngự Lâm Mạng Java (InetAddress, URL, URLConnection)",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-4/",
      "summary": "\u003cp\u003eTrước khi bắt tay vào xây dựng các \u0026ldquo;đường hầm\u0026rdquo; (Sockets) phức tạp để giao tiếp hai chiều, mọi lập trình viên mạng cần nắm vững cách xác định và tương tác với \u0026ldquo;địa chỉ\u0026rdquo; trên Internet. Giống như bạn không thể gửi thư nếu không biết địa chỉ người nhận, chương trình Java cũng không thể kết nối nếu không biết \u0026ldquo;tọa độ\u0026rdquo; của máy chủ đích.\u003c/p\u003e\n\u003cp\u003eTrong Java, có ba lớp cốt lõi, như \u0026ldquo;ba chàng ngự lâm\u0026rdquo;, giúp bạn xử lý các vấn đề về địa chỉ và kết nối cơ bản: \u003ccode\u003eInetAddress\u003c/code\u003e, \u003ccode\u003eURL\u003c/code\u003e, và \u003ccode\u003eURLConnection\u003c/code\u003e.\u003c/p\u003e",
      "content": "Trước khi bắt tay vào xây dựng các \u0026ldquo;đường hầm\u0026rdquo; (Sockets) phức tạp để giao tiếp hai chiều, mọi lập trình viên mạng cần nắm vững cách xác định và tương tác với \u0026ldquo;địa chỉ\u0026rdquo; trên Internet. Giống như bạn không thể gửi thư nếu không biết địa chỉ người nhận, chương trình Java cũng không thể kết nối nếu không biết \u0026ldquo;tọa độ\u0026rdquo; của máy chủ đích.\nTrong Java, có ba lớp cốt lõi, như \u0026ldquo;ba chàng ngự lâm\u0026rdquo;, giúp bạn xử lý các vấn đề về địa chỉ và kết nối cơ bản: InetAddress, URL, và URLConnection.\n1. InetAddress: Tấm Bản Đồ Tra Cứu Tọa Độ IP 🗺️\rTrong thế giới thực, chúng ta dùng địa chỉ nhà (Số 10, phố Quang Trung) vì nó dễ nhớ. Nhưng hệ thống định vị (GPS) lại cần tọa độ (21.02° N, 105.85° E) để tìm đường.\nTrên Internet cũng vậy:\nTên miền (Domain Name): Như google.com, facebook.com. Con người dễ nhớ, dễ gõ. Địa chỉ IP (IP Address): Như 142.250.204.142 (IPv4) hoặc 2404:6800:4003:c07::8e (IPv6). Đây là \u0026ldquo;tọa độ\u0026rdquo; thật sự mà các thiết bị mạng (router) dùng để tìm đường đi cho dữ liệu. Lớp java.net.InetAddress chính là \u0026ldquo;cuốn danh bạ\u0026rdquo; hay \u0026ldquo;tấm bản đồ\u0026rdquo; giúp bạn thực hiện Phân giải Tên miền (DNS Lookup): chuyển đổi giữa tên miền dễ nhớ và địa chỉ IP khó nhớ.\nDNS Lookup: Phép Thuật Phía Sau Hậu Trường\rKhi bạn gọi InetAddress.getByName(\u0026quot;google.com\u0026quot;), điều gì xảy ra?\nChương trình Java của bạn hỏi Hệ điều hành (Windows, Linux\u0026hellip;). Hệ điều hành kiểm tra cache DNS cục bộ (xem gần đây có tra cứu google.com chưa). Nếu không có, nó hỏi máy chủ DNS được cấu hình trong mạng của bạn (thường là của nhà mạng VNPT, FPT\u0026hellip;). Máy chủ DNS này có thể lại phải hỏi các máy chủ DNS cấp cao hơn (Root DNS, TLD DNS\u0026hellip;). Cuối cùng, một máy chủ DNS \u0026ldquo;có thẩm quyền\u0026rdquo; cho google.com sẽ trả về(các) địa chỉ IP tương ứng. Kết quả IP được trả về cho chương trình Java của bạn dưới dạng đối tượng InetAddress. Ví Dụ Chi Tiết Hơn\rimport java.net.InetAddress; import java.net.UnknownHostException; import java.util.Arrays; public class InetAddressAdvancedDemo { public static void main(String[] args) { String[] domains = {\u0026#34;google.com\u0026#34;, \u0026#34;facebook.com\u0026#34;, \u0026#34;vnexpress.net\u0026#34;, \u0026#34;invalid-domain-xyz123.com\u0026#34;}; for (String domain : domains) { System.out.println(\u0026#34;--- Phân giải tên miền: \u0026#34; + domain + \u0026#34; ---\u0026#34;); try { // Lấy TẤT CẢ các địa chỉ IP liên kết với tên miền này // (Nhiều trang lớn dùng nhiều IP để cân bằng tải - Load Balancing) InetAddress[] addresses = InetAddress.getAllByName(domain); System.out.println(\u0026#34;Tìm thấy \u0026#34; + addresses.length + \u0026#34; địa chỉ IP:\u0026#34;); for (InetAddress addr : addresses) { System.out.println(\u0026#34; - Host Name: \u0026#34; + addr.getHostName()); // Có thể vẫn là domain hoặc tên cụ thể hơn System.out.println(\u0026#34; IP Address: \u0026#34; + addr.getHostAddress()); System.out.println(\u0026#34; Is Loopback: \u0026#34; + addr.isLoopbackAddress()); // Có phải là localhost (127.0.0.1)? System.out.println(\u0026#34; Is Site Local: \u0026#34; + addr.isSiteLocalAddress()); // Có phải IP mạng nội bộ (192.168...)? } } catch (UnknownHostException e) { // Xảy ra khi tên miền không tồn tại hoặc máy chủ DNS không phản hồi System.err.println(\u0026#34; LỖI: Không thể phân giải tên miền \u0026#39;\u0026#34; + domain + \u0026#34;\u0026#39;. Lý do: \u0026#34; + e.getMessage()); } System.out.println(); // In dòng trống cho dễ nhìn } // Lấy thông tin máy hiện tại try { System.out.println(\u0026#34;--- Thông tin máy cục bộ ---\u0026#34;); InetAddress localhost = InetAddress.getLocalHost(); System.out.println(\u0026#34; My Host Name: \u0026#34; + localhost.getHostName()); System.out.println(\u0026#34; My IP Address: \u0026#34; + localhost.getHostAddress()); } catch (UnknownHostException e) { System.err.println(\u0026#34; LỖI: Không lấy được thông tin máy cục bộ.\u0026#34;); } } } ",
      "categories": ["Networking"],
      "tags": ["Java","Networking","IP","URL"]
    },
    {
      "title": "Đa Tuyến (Multithreading) - Biến Hóa Phân Thân, Xử Lý Song Song",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-3/",
      "summary": "\u003cp\u003eHãy tưởng tượng bạn đang xây dựng một ứng dụng Java phức tạp, ví dụ một trình duyệt web.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eChạy đơn tuyến (Single-threaded):\u003c/strong\u003e Nếu bạn chỉ có một \u0026ldquo;luồng thực thi\u0026rdquo; (thread) duy nhất, nó phải làm mọi thứ tuần tự. Khi bạn bấm tải một trang web lớn, luồng đó bận rộn tải dữ liệu, và toàn bộ giao diện người dùng (các nút bấm, thanh cuộn) sẽ bị \u0026ldquo;đơ\u0026rdquo; (freeze) cho đến khi tải xong. Trải nghiệm cực kỳ tệ! 🥶\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eChạy đa tuyến (Multi-threaded):\u003c/strong\u003e Bạn có thể tạo ra nhiều luồng:\n\u003cul\u003e\n\u003cli\u003eLuồng chính (UI Thread): Chỉ lo vẽ giao diện, đảm bảo nút bấm luôn nhạy.\u003c/li\u003e\n\u003cli\u003eLuồng tải dữ liệu 1: Đi tải HTML.\u003c/li\u003e\n\u003cli\u003eLuồng tải dữ liệu 2: Đi tải ảnh.\u003c/li\u003e\n\u003cli\u003eLuồng tải dữ liệu 3: Đi tải CSS/JavaScript.\nCác luồng tải dữ liệu chạy ngầm, không làm ảnh hưởng đến luồng giao diện. Kết quả: Trình duyệt của bạn mượt mà, phản hồi nhanh nhạy. ✨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eĐây chính là sức mạnh của \u003cstrong\u003eĐa tuyến (Multithreading)\u003c/strong\u003e. Nó cho phép một chương trình thực hiện nhiều tác vụ \u003cstrong\u003eđồng thời\u003c/strong\u003e (concurrently) hoặc \u003cstrong\u003esong song\u003c/strong\u003e (parallel, nếu máy có nhiều CPU core), bằng cách tạo ra các \u0026ldquo;tiểu trình\u0026rdquo; (Thread) độc lập.\u003c/p\u003e",
      "content": "Hãy tưởng tượng bạn đang xây dựng một ứng dụng Java phức tạp, ví dụ một trình duyệt web.\nChạy đơn tuyến (Single-threaded): Nếu bạn chỉ có một \u0026ldquo;luồng thực thi\u0026rdquo; (thread) duy nhất, nó phải làm mọi thứ tuần tự. Khi bạn bấm tải một trang web lớn, luồng đó bận rộn tải dữ liệu, và toàn bộ giao diện người dùng (các nút bấm, thanh cuộn) sẽ bị \u0026ldquo;đơ\u0026rdquo; (freeze) cho đến khi tải xong. Trải nghiệm cực kỳ tệ! 🥶 Chạy đa tuyến (Multi-threaded): Bạn có thể tạo ra nhiều luồng: Luồng chính (UI Thread): Chỉ lo vẽ giao diện, đảm bảo nút bấm luôn nhạy. Luồng tải dữ liệu 1: Đi tải HTML. Luồng tải dữ liệu 2: Đi tải ảnh. Luồng tải dữ liệu 3: Đi tải CSS/JavaScript. Các luồng tải dữ liệu chạy ngầm, không làm ảnh hưởng đến luồng giao diện. Kết quả: Trình duyệt của bạn mượt mà, phản hồi nhanh nhạy. ✨ Đây chính là sức mạnh của Đa tuyến (Multithreading). Nó cho phép một chương trình thực hiện nhiều tác vụ đồng thời (concurrently) hoặc song song (parallel, nếu máy có nhiều CPU core), bằng cách tạo ra các \u0026ldquo;tiểu trình\u0026rdquo; (Thread) độc lập.\nTrong Lập trình Mạng, một Server bắt buộc phải là đa tuyến. Nó không thể \u0026ldquo;đơ\u0026rdquo; toàn bộ hệ thống chỉ vì đang phục vụ một Client. Nó phải sẵn sàng tiếp nhận và xử lý hàng trăm, hàng ngàn Client cùng lúc.\nLợi Ích và Thách Thức\rLợi ích:\nTăng khả năng phản hồi (Responsiveness): Giao diện người dùng không bị \u0026ldquo;đơ\u0026rdquo; khi có tác vụ nặng chạy ngầm. Tận dụng CPU đa nhân (Performance): Nếu máy có nhiều CPU core, các thread có thể chạy song song thực sự, tăng tốc độ xử lý. Chia sẻ tài nguyên hiệu quả: Các thread trong cùng một process có thể chia sẻ bộ nhớ (dữ liệu) dễ dàng hơn so với các process riêng biệt. Thách thức:\nPhức tạp (Complexity): Quản lý nhiều luồng khó hơn nhiều so với một luồng. Vấn đề Đồng bộ hóa (Synchronization): Khi nhiều luồng cùng truy cập và thay đổi một dữ liệu chung, có thể xảy ra lỗi \u0026ldquo;dẫm chân lên nhau\u0026rdquo; (race condition), dẫn đến dữ liệu sai lệch. Cần các cơ chế khóa (lock) để bảo vệ. Deadlock: Hai hay nhiều luồng chờ đợi lẫn nhau mãi mãi, không luồng nào chạy tiếp được. Tốn tài nguyên: Mỗi thread cũng tiêu tốn một ít bộ nhớ và CPU để quản lý. Tạo Thread trong Java: Kế Thừa vs. Hợp Đồng\rNhư đã đề cập, có 2 cách chính:\nCách làm : extends Thread\rTạo một lớp kế thừa trực tiếp từ java.lang.Thread và override phương thức run().\nclass MyThread extends Thread { private String taskName; public MyThread(String name) { this.taskName = name; } @Override public void run() { System.out.println(\u0026#34;Thread \u0026#39;\u0026#34; + taskName + \u0026#34;\u0026#39; đang chạy...\u0026#34;); // Làm việc gì đó... try { Thread.sleep(1000); } catch (InterruptedException e) {} System.out.println(\u0026#34;Thread \u0026#39;\u0026#34; + taskName + \u0026#34;\u0026#39; kết thúc.\u0026#34;); } } // Cách sử dụng: MyThread t1 = new MyThread(\u0026#34;Task A\u0026#34;); t1.start(); // Quan trọng: Gọi start() để tạo luồng mới ",
      "categories": ["Java"],
      "tags": ["Java","Multithreading","Concurrency"]
    },
    {
      "title": "Luồng (Stream) trong Java - Đường Ống Dẫn Dữ Liệu Tinh Tế",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-2/",
      "summary": "\u003cp\u003eTrong bài 1, chúng ta đã gặp Java, gã khổng lồ đa nền tảng. Nhưng một chương trình mạnh mẽ đến đâu cũng cần \u0026ldquo;giao tiếp\u0026rdquo; với thế giới bên ngoài: đọc dữ liệu cấu hình từ file, lưu trạng thái người dùng, nhận yêu cầu từ mạng, gửi phản hồi đi\u0026hellip; Tất cả những hoạt động \u0026ldquo;ra vào\u0026rdquo; này trong Java đều xoay quanh một khái niệm trung tâm: \u003cstrong\u003eStream (Luồng)\u003c/strong\u003e. 🌊\u003c/p\u003e",
      "content": "Trong bài 1, chúng ta đã gặp Java, gã khổng lồ đa nền tảng. Nhưng một chương trình mạnh mẽ đến đâu cũng cần \u0026ldquo;giao tiếp\u0026rdquo; với thế giới bên ngoài: đọc dữ liệu cấu hình từ file, lưu trạng thái người dùng, nhận yêu cầu từ mạng, gửi phản hồi đi\u0026hellip; Tất cả những hoạt động \u0026ldquo;ra vào\u0026rdquo; này trong Java đều xoay quanh một khái niệm trung tâm: Stream (Luồng). 🌊\nHãy tưởng tượng Stream như một đường ống nước một chiều. \u0026ldquo;Nước\u0026rdquo; chính là dữ liệu (data), chảy tuần tự từng chút một. Chương trình của bạn có thể lắp đặt đường ống để:\nNhận nước vào (Input Stream): Đọc dữ liệu từ một nguồn (file, bàn phím, kết nối mạng). Xả nước ra (Output Stream): Ghi dữ liệu đến một đích (file, màn hình, kết nối mạng). Java I/O API cung cấp một hệ thống \u0026ldquo;ống nước\u0026rdquo; cực kỳ linh hoạt và mạnh mẽ.\nPhân Loại Ống Nước: Byte vs. Character\rJava chia các loại ống thành 2 họ chính, dựa trên loại \u0026ldquo;nước\u0026rdquo; chúng vận chuyển:\n1. Byte Streams (Luồng Byte) - Vận Chuyển \u0026ldquo;Nước Thô\u0026rdquo; 🧱\rĐây là loại ống cơ bản nhất, xử lý dữ liệu dưới dạng byte (8 bit). Nó dùng để đọc/ghi mọi loại dữ liệu: file nhị phân (ảnh .jpg, video .mp4, file thực thi .exe), dữ liệu nén, và cả file text thô. Các lớp trừu tượng gốc là InputStream và OutputStream. Các lớp cụ thể phổ biến: FileInputStream / FileOutputStream: Đọc/ghi file. ByteArrayInputStream / ByteArrayOutputStream: Đọc/ghi từ mảng byte trong bộ nhớ. ObjectInputStream / ObjectOutputStream: Đọc/ghi đối tượng Java (sẽ học ở bài Serialization). 2. Character Streams (Luồng Ký Tự) - Vận Chuyển \u0026ldquo;Nước Tinh Khiết\u0026rdquo; (Văn Bản) 📄\rLoại ống này được tối ưu hóa đặc biệt cho việc đọc/ghi dữ liệu văn bản (text). Nó xử lý dữ liệu dưới dạng ký tự (char) (16 bit trong Java, hỗ trợ Unicode). Điểm mạnh: Nó tự động xử lý việc chuyển đổi mã hóa (encoding). Khi bạn đọc một file text (có thể là UTF-8, ANSI\u0026hellip;), Character Stream sẽ tự động dịch các byte thành ký tự Java Unicode chuẩn xác, giúp bạn hiển thị tiếng Việt, tiếng Nhật\u0026hellip; mà không bị lỗi font chữ \u0026ldquo;?\u0026rdquo;. Các lớp trừu tượng gốc là Reader và Writer. Các lớp cụ thể phổ biến: FileReader / FileWriter: Đọc/ghi file text (cách đơn giản). BufferedReader / BufferedWriter: Đọc/ghi text hiệu quả hơn nhờ bộ đệm. InputStreamReader / OutputStreamWriter: Là những \u0026ldquo;cây cầu nối\u0026rdquo; quan trọng, giúp chuyển đổi giữa Byte Stream và Character Stream. Ví dụ, bạn có InputStream từ mạng (là byte stream), bạn có thể bọc nó bằng InputStreamReader để đọc text dễ dàng. Khi nào dùng loại nào?\nDữ liệu nhị phân (ảnh, âm thanh, file nén\u0026hellip;) =\u0026gt; Byte Streams. Dữ liệu văn bản (code, HTML, JSON, log\u0026hellip;) =\u0026gt; Character Streams. Sức Mạnh Kết Hợp: Mô Hình Decorator 🪄\rĐiều làm cho Java I/O trở nên linh hoạt là khả năng \u0026ldquo;lắp ráp\u0026rdquo; các luồng lại với nhau, giống như bạn lắp các đoạn ống nước có chức năng khác nhau. Đây là một mẫu thiết kế (Design Pattern) nổi tiếng gọi là Decorator.\nBạn có một luồng cơ bản (ví dụ: FileInputStream đọc file), nhưng nó chỉ có chức năng đọc byte thô. Bạn có thể \u0026ldquo;bọc\u0026rdquo; (wrap) nó bằng các luồng \u0026ldquo;trang trí\u0026rdquo; khác để thêm tính năng:\nFileInputStream -\u0026gt; BufferedInputStream (Thêm bộ đệm, đọc nhanh hơn) FileInputStream -\u0026gt; DataInputStream (Thêm khả năng đọc các kiểu dữ liệu nguyên thủy như int, double) FileInputStream -\u0026gt; InputStreamReader (Chuyển byte thành ký tự) -\u0026gt; BufferedReader (Đọc cả dòng text) Bạn có thể lồng nhiều lớp \u0026ldquo;trang trí\u0026rdquo; vào nhau!\nVí dụ : Copy File Ảnh (Dùng Byte Stream \u0026amp; Buffer)\rHãy xem cách dùng FileInputStream, FileOutputStream và bộ đệm (BufferedInputStream, BufferedOutputStream) để copy một file ảnh.\nimport java.io.*; public class FileCopyByteStreamDemo { public static void main(String[] args) { String sourceFile = \u0026#34;input.jpg\u0026#34;; // Đặt file ảnh của bạn ở đây String destinationFile = \u0026#34;output_copy.jpg\u0026#34;; // Sử dụng try-with-resources để đảm bảo luồng tự đóng try ( InputStream fis = new FileInputStream(sourceFile); BufferedInputStream bis = new BufferedInputStream(fis); // Bọc thêm buffer đọc OutputStream fos = new FileOutputStream(destinationFile); BufferedOutputStream bos = new BufferedOutputStream(fos) // Bọc thêm buffer ghi ) { byte[] buffer = new byte[4096]; // Tạo bộ đệm 4KB int bytesRead; System.out.println(\u0026#34;Bắt đầu copy file...\u0026#34;); // Đọc từ bis vào buffer, ghi từ buffer ra bos // bis.read(buffer) trả về số byte đã đọc, hoặc -1 nếu hết file while ((bytesRead = bis.read(buffer)) != -1) { bos.write(buffer, 0, bytesRead); // Chỉ ghi đúng số byte đã đọc } System.out.println(\u0026#34;Copy file thành công!\u0026#34;); } catch (FileNotFoundException e) { System.err.println(\u0026#34;Lỗi: Không tìm thấy file nguồn: \u0026#34; + sourceFile); } catch (IOException e) { System.err.println(\u0026#34;Lỗi I/O: \u0026#34; + e.getMessage()); } } } ",
      "categories": ["Java"],
      "tags": ["Java","I/O","Stream"]
    },
    {
      "title": "Gã Khổng Lồ 'Write Once, Run Anywhere'",
      "permalink": "http://localhost:1313/posts/bai-viet-java-so-1/",
      "summary": "\u003cp\u003eChào bạn! Chắc hẳn bạn đã nghe nói về \u0026ldquo;Lập trình Hướng đối tượng\u0026rdquo; (OOP), về các hệ thống ngân hàng tỷ đô, hay về ứng dụng Android. Đứng đằng sau rất nhiều trong số đó, là một gã khổng lồ thầm lặng: \u003cstrong\u003eJava\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNhưng tại sao Java lại trở nên quyền lực như vậy?\u003c/p\u003e\n\u003cp\u003eHãy tưởng tượng bạn là một kiến trúc sư vĩ đại.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNếu bạn xây nhà bằng C++, bạn phải là chuyên gia về nền đất. Bạn xây nhà trên \u0026ldquo;nền đất Windows\u0026rdquo;, bạn phải dùng vật liệu của Windows. Khi sang \u0026ldquo;nền đất macOS\u0026rdquo;, bạn phải thiết kế lại móng và tường để chịu được \u0026ldquo;thời tiết\u0026rdquo; của macOS. Cực kỳ tốn công!\u003c/li\u003e\n\u003cli\u003eVới Java, bạn không cần quan tâm đến nền đất. Bạn chỉ cần tập trung thiết kế một \u003cstrong\u003e\u0026ldquo;bản vẽ thần kỳ\u0026rdquo; (Magic Blueprint)\u003c/strong\u003e duy nhất.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSau đó, bạn đưa \u0026ldquo;bản vẽ\u0026rdquo; này cho \u0026ldquo;Đội Thi Công\u0026rdquo; tại bất kỳ đâu (Windows, macOS, Linux). \u0026ldquo;Đội Thi Công\u0026rdquo; tại mỗi nơi sẽ tự động đọc bản vẽ của bạn và xây nên ngôi nhà y hệt, một cách hoàn hảo.\u003c/p\u003e",
      "content": "Chào bạn! Chắc hẳn bạn đã nghe nói về \u0026ldquo;Lập trình Hướng đối tượng\u0026rdquo; (OOP), về các hệ thống ngân hàng tỷ đô, hay về ứng dụng Android. Đứng đằng sau rất nhiều trong số đó, là một gã khổng lồ thầm lặng: Java.\nNhưng tại sao Java lại trở nên quyền lực như vậy?\nHãy tưởng tượng bạn là một kiến trúc sư vĩ đại.\nNếu bạn xây nhà bằng C++, bạn phải là chuyên gia về nền đất. Bạn xây nhà trên \u0026ldquo;nền đất Windows\u0026rdquo;, bạn phải dùng vật liệu của Windows. Khi sang \u0026ldquo;nền đất macOS\u0026rdquo;, bạn phải thiết kế lại móng và tường để chịu được \u0026ldquo;thời tiết\u0026rdquo; của macOS. Cực kỳ tốn công! Với Java, bạn không cần quan tâm đến nền đất. Bạn chỉ cần tập trung thiết kế một \u0026ldquo;bản vẽ thần kỳ\u0026rdquo; (Magic Blueprint) duy nhất. Sau đó, bạn đưa \u0026ldquo;bản vẽ\u0026rdquo; này cho \u0026ldquo;Đội Thi Công\u0026rdquo; tại bất kỳ đâu (Windows, macOS, Linux). \u0026ldquo;Đội Thi Công\u0026rdquo; tại mỗi nơi sẽ tự động đọc bản vẽ của bạn và xây nên ngôi nhà y hệt, một cách hoàn hảo.\n\u0026ldquo;Bản vẽ thần kỳ\u0026rdquo; đó gọi là Bytecode. Và \u0026ldquo;Đội Thi Công\u0026rdquo; đó chính là Máy ảo Java (JVM).\nĐây chính là triết lý đã làm nên tên tuổi của Java:\n\u0026ldquo;Write Once, Run Anywhere\u0026rdquo; (Viết một nơi, Chạy khắp chốn)\nJava Thực Sự Là Gì? \u0026ldquo;Giải Nén\u0026rdquo; 4 Tính Chất Cốt Lõi\rJava là một ngôn ngữ lập trình bậc cao, hướng đối tượng, bảo mật, và đa nền tảng. Chúng ta sẽ \u0026ldquo;giải nén\u0026rdquo; từng cái.\n1. Đa nền tảng (Platform Independent)\rĐây là điều chúng ta vừa nói. Nhờ có Máy ảo Java (JVM), code của bạn (đã được biên dịch thành Bytecode) có thể chạy trên mọi hệ điều hành mà không cần sửa đổi một dòng code nào.\n2. Hướng đối tượng (Object-Oriented Programming - OOP)\rĐây không chỉ là một tính năng, đây là một triết lý lập trình.\nThay vì viết các hàm (procedures) rời rạc, OOP giúp bạn mô phỏng thế giới thực vào trong code. Bạn tạo ra các \u0026ldquo;Khuôn mẫu\u0026rdquo; (Class) và đúc ra các \u0026ldquo;Đối tượng\u0026rdquo; (Object).\nClass (Lớp): Là một bản thiết kế. Ví dụ: Bản thiết kế XeHoi. Object (Đối tượng): Là một sản phẩm cụ thể được đúc từ bản thiết kế đó. Ví dụ: xeCuaTung (màu đỏ, 4 bánh) và xeCuaBan (màu xanh, 2 bánh) là 2 đối tượng từ cùng lớp XeHoi. Chúng ta sẽ nói về 4 trụ cột của OOP (Đóng gói, Kế thừa, Đa hình, Trừu tượng) trong các bài viết sau.\n3. Bậc cao \u0026amp; Tự động \u0026ldquo;Dọn Rác\u0026rdquo; (Garbage Collection)\rJava là ngôn ngữ bậc cao (gần với ngôn ngữ người). Một trong những tính năng \u0026ldquo;ăn tiền\u0026rdquo; nhất là Automatic Garbage Collection (Tự động thu gom rác).\nTrong các ngôn ngữ như C++, bạn phải tự mình quản lý bộ nhớ. Bạn \u0026ldquo;mượn\u0026rdquo; một ô nhớ, dùng xong, bạn phải \u0026ldquo;trả\u0026rdquo; lại. Nếu bạn quên \u0026ldquo;trả\u0026rdquo;, ô nhớ đó bị chiếm dụng mãi mãi (gọi là \u0026ldquo;memory leak\u0026rdquo;), và chương trình của bạn sẽ sập vì hết bộ nhớ.\nVới Java, JVM hành động như một \u0026ldquo;quản gia\u0026rdquo; mẫn cán. JVM tự động theo dõi xem ô nhớ nào không còn ai dùng đến nữa, và nó sẽ tự đi \u0026ldquo;thu dọn\u0026rdquo; (giải phóng) ô nhớ đó. Điều này giúp lập trình viên tập trung vào logic nghiệp vụ thay vì lo lắng về quản lý bộ nhớ.\n4. Bảo mật (Secure)\rNhờ việc chạy code bên trong một \u0026ldquo;hộp cát\u0026rdquo; (sandbox) của JVM, Java ngăn chặn các đoạn mã độc truy cập trực tiếp vào phần cứng hoặc các vùng nhớ nhạy cảm của hệ điều hành, khiến nó an toàn hơn cho các ứng dụng mạng.\nKiến Trúc Thần Kỳ: JVM \u0026amp; Bytecode Hoạt Động\rHãy xem lại quy trình 3 bước từ code đến lúc chạy:\nViết Code (File .java): Bạn viết code bằng ngôn ngữ Java, ví dụ Student.java. Biên dịch (File .class): Bạn chạy trình biên dịch javac (Java Compiler). javac Student.java Lệnh này không tạo ra file .exe cho Windows. Nó tạo ra \u0026ldquo;bản vẽ thần kỳ\u0026rdquo; Student.class, chứa mã Java Bytecode trung gian. Thực thi (JVM): Bạn dùng lệnh java để yêu cầu JVM chạy. java Student Lúc này, \u0026ldquo;Đội Thi Công\u0026rdquo; JVM tại máy của bạn (Windows JVM, Mac JVM\u0026hellip;) sẽ đọc file .class đó, thông dịch (hoặc biên dịch JIT) nó ra mã máy gốc của hệ điều hành đó và thực thi. Code Example: Không Chỉ Là \u0026ldquo;Hello, World!\u0026rdquo;\rHãy làm một ví dụ phức tạp hơn, thể hiện sức mạnh của \u0026ldquo;Hướng đối tượng\u0026rdquo;. Chúng ta sẽ tạo một \u0026ldquo;Khuôn mẫu\u0026rdquo; Student và một chương trình School để tạo ra các sinh viên.\nFile 1: Student.java (Lớp - Khuôn mẫu)\r// Đây là \u0026#34;bản thiết kế\u0026#34; hay \u0026#34;khuôn mẫu\u0026#34; cho một sinh viên // Nó không phải là một chương trình chạy được public class Student { // 1. Thuộc tính (Properties) - Đặc điểm của đối tượng String name; int age; String studentID; // 2. Constructor - \u0026#34;Cỗ máy\u0026#34; để đúc ra đối tượng từ khuôn // Tên của nó phải trùng với tên Class public Student(String name, int age, String id) { // \u0026#34;this.name\u0026#34; là \u0026#34;name\u0026#34; của đối tượng // \u0026#34;name\u0026#34; (bên phải) là tham số đầu vào this.name = name; this.age = age; this.studentID = id; System.out.println(\u0026#34;Đã tạo sinh viên: \u0026#34; + this.name); } // 3. Phương thức (Method) - Hành vi của đối tượng public void displayInfo() { System.out.println(\u0026#34;--- Thông tin Sinh viên ---\u0026#34;); System.out.println(\u0026#34;Tên: \u0026#34; + name); System.out.println(\u0026#34;Tuổi: \u0026#34; + age); System.out.println(\u0026#34;MSSV: \u0026#34; + studentID); System.out.println(\u0026#34;---------------------------\u0026#34;); } } ",
      "categories": ["Java"],
      "tags": ["Java","Giới thiệu","JVM"]
    }]